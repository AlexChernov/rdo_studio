Стиль исходного кода РДО:

1. комментарии.
1.0. язык комментариев русский или английский.
1.1. Для автоматизации процесса создания документации системы и для структуризации комментариев исходного кода РДО в системе принят стандарт комментариев Doxygen.
1.2. В обязательном порядке докумментируются
1.2.1. файлы
1.2.2. пользовательские типы данных:
классы                   - class
интерфейсы               - такого понятия в C++ нет. под интерфейсами подразумеваются классы, не имеющие ни членов-данных, ни членов-функций кроме чисто виртуальных, имена которых начинаются с буквы I
стуруктуры               - struct
именованные перечисления - enum
объединения              - union
1.2.3. интерфейсные (public) методы
1.2.4. макросы           - #define //кроме стражей включения
1.2.5. синонимы типов данных в простанствах имен и глобальные - typedef
1.3. Стиль doxy-комментариев - Qt-style:
/******************************************************************************//**
 * @class   RDORSuperClass
 * @brief   Просто супер класс РДО
 * @details Не пишется курсовой, не собирается РДО - просто отнаследуйтесь от этого класса!:)
 *********************************************************************************/

1.4. при комментировании файла необходимо указывать себя в формате: Фамилия Имя. На русском.

2. стражи включения.
2.1. имя макроса-стража пишется большими буквами, знаком подчеркивания и ничем больше.
2.2. имя макроса-стража начинается и заканчивается единичным знаком подчеркивания. между ними пишется имя файла с упоминанием всех директорий (библиотек) от корня РДО, где он находится, но без включения слова RDO. Смысловые части слов разделяется единичным знаком подчеркивания (даже в том случае, если в названии файла они написаны слитно). Например, так будут выглядеть стражи для следующих файлов:
\rdo_studio\rdo_lib\rdo_parser\expression.h      _LIB_PARSER_EXPRESSION_H_
\rdo_studio\rdo_lib\rdo_runtime\rdodptrtime.h    _LIB_RUNTIME_DPT_RTIME_H_
\rdo_studio\rdo_lib\rdo_runtime\rdo_res_type_i.h _LIB_RUNTIME_RES_TYPE_H_

3. файлы.
3.1. создавая новый класс, необходимо придерживаться модели h + inl + cpp. Она подразумевает, что заголовочный файл (*.h) содержит только декларацию методов. Встроенные методы (inline), следует реализовывать в (*.inl)-файле. Обычные - в соответствующем (*.cpp)-файле. При этом, *.h должен содержать #include на свой *.inl, указываемый в самом конце (*.h)-файла, перед закрытием стража.

4. типы данных.
4.1. использовать встроенные типы данных, такие как: int, unsigned, long, float, double, char, bool, * (указатель), & (ссылка) и библиотечный класс std::basic_string<char> (std::string) запрещено. Краткая таблица синонимом

std::string            -> tstring
bool                   -> rbool
signed int             -> rsint
unsigned int           -> ruint
signed long long int   -> rsint64
unsigned long long int -> ruint64
unsigned char          -> rbyte

A&                     -> REF(A)
const A&               -> CREF(A)
A*                     -> PTR(A)
const A*               -> CPTR(A)
const A* const         -> CPTRC(A)

Все синонимы можно посмотреть в rdo_common\rdotypes.h и \rdomacros.h.

5. использование ключевых слов C++ и макросов.
5.1. кроме специально оговоренных случаев создавать макросы запрещается
5.2. class/struct не пользоваться - пользоваться макросами
5.2. using namespace для РДО-исходников запрещен - пользоваться макросами
5.4. using namespace для внешних библиотек (std, boost...) запрещен, идентификаторы пишются полность, например, std::cout
5.3. оператором new пользоваться нельзя - пользуйтесь фабрикой (rdo::Factory)
5.5. строчки и отдельные символы заключаются в макрос _T: _T("some text"), _T('a')
5.6. при описании контейнера необходимо использовать typedef

'старый' код
std::list<ruint> intList;

std::list<ruint>::iterator it = intList.begin();
while (it != intList.end())
{
	...
	++it;
}

'новый' код
typedef std::list<ruint> IntList;
IntList intList;

IntList::iterator it = intList.begin();
while (it != intList.end())
{
	...
	++it;
}

'совсем новый' код
typedef std::list<ruint> IntList;
IntList intList;

STL_FOR_ALL(intList, it)
{
	...
}

5.7. При использовании итераторов использовать префиксную нотацию
++it;
--it;
вместо
it++;
it--;
за исключением случаев, когда вы точно уверены, что необходимо второе.

6. названия методов и атрибутов
6.1. должны быть настолько понятными, чтобы не возникало желания писать комментарий
6.2. атрибуты (переменные класса) начинаются с m_, пишутся с маленькой буквы
ruint   m_count;
tstring m_message;

6.3. указатели начинаются с символа p
PTR(A) pA = ... //! для локальной переменной
PTR(A) m_pA;    //! для атрибута

6.4. Названия методов и функций начинается с маленькой буквы, никаких префиксов не имеют
void fun();

6.5. Если название атрибута/метода длинное (состоит из нескольких слов), то они указываются с большой буквы, начиная со второго. подчеркивания не допускаются (кроме m_)
ruint m_errorCounter;         //! атрибут
ruint errorCounter;           //! локальная перемнная
ruint getErrorCounter() const //! метод класса

6.6. Для константных методов не ленитесь писать модификатор const
6.7. глобальные переменные/статические атрибуты начинаются с префикса s_
6.8. Как именуются переменные в пространстве имен? например, rdoRuntime::g_int.
 
7. переносы строк и символы разделители.
7.1. открывающую фигурную скобку писать на новой строке
if (a > b)
{
	return true;
}

7.2. else тоже пишется с новой строки
if (a > b)
{
	return true;
}
else
{
	return false;
}

7.3. многоярусные if-else можно писать без набегающего отступа слева, например
if (str == _T("a1"))
{
}
else if (str == _T("a2"))
{
}
else if (str == _T("a3"))
{
}
Но подобные конструкции настоятельно не рекомендуются к использованию и свидетельствуют о плохом дизайне функции.

7.4. табуляция - 4T (вставляется символ табуляции, его длина равна четырём символам). если в качестве редактора исходных кодов вы пользуетесь ms visual studio (настроенной по умолчанию), то выравнивание текста слева по умолчанию правильное, т.е. самостоятельно пользоваться табуляцией не нужно (имеется ввиду "идеальный" набор текста без исправлений, возвратов, стираний и т.д.).
